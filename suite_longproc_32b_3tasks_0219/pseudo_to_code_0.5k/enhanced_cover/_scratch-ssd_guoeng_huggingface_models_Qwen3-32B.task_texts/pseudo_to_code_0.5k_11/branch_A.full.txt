<think>
Okay, let's see. I need to convert this pseudocode into C++ code. Let me go through each part step by step.

First, the pseudocode mentions creating an integer sum. So in C++, I'll need a global variable or a static variable inside a function. But looking at the add function, it's modifying sum. Oh right, in the main function, there's a loop where for each i from 3 to n exclusive, they call add(n, i). The add function adds to sum. So sum must be a global variable. So I'll declare int sum; outside.

Next, the gcd function. The function takes a and b. The base case is if a % b is 0, return b. Otherwise, return gcd(b, a%b). Wait, but in C++, the function needs to be declared. So I'll write a function int gcd(int a, int b) { if (a % b == 0) return b; else return gcd(b, a%b); } But wait, what if b is 0? But in the main function, when we call gcd(sum, n-2), sum is the sum of digits in base i, which is at least 1 (since n is at least 2?), and n-2 could be 1 or more. Hmm, but maybe the initial call in main is with n-2 as the second argument. Let's think: when n is read, and the loop is for i from 2 to n exclusive. For example, if n is 2, the loop doesn't run. But in that case, sum remains 0, and then div is gcd(0, 0)? Wait, but if n is 2, then n-2 is 0. So sum would be 0 (since add is never called), and then trying to compute gcd(0, 0) would be a problem. But maybe the problem constraints ensure that n is large enough. The pseudocode says to read n, but perhaps in practice, n is at least 3. But I'll proceed as per the pseudocode.

Then the add function. It takes n and x, and while n is not 0, adds n%x to sum, then sets n = n/x. So the function is void add(int n, int x). Wait, but in C++, parameters are passed by value, so modifying n inside the function won't affect the original. But the pseudocode says "set n to n / x". So the function is using a local copy of n. That's correct. So the function is:

void add(int n, int x) {
    while (n != 0) {
        sum += n % x;
        n = n / x;
    }
}

Now, the main function. Read n. Then for i from 2 to n exclusive, call add(n, i). Then compute div as gcd(sum, n-2). Then print sum/div followed by '/' and (n-2)/div.

Wait, but sum is accumulated across all calls to add. So in the main function, sum must be reset to 0 before the loop. Oh, right! The pseudocode says "create integer sum" and then in the main function, the add calls are made. But in the initial part, the pseudocode says "create integer sum" once. But in the main function, each time when processing a new n, the sum should be reset. Wait, looking at the pseudocode:

The pseudocode says:

define main function
    create integer n
    read n
    for i=2 to n exclusive, run add with n, i
    create integer div ...
So the sum variable must be declared outside, but in each run of main, sum is initially 0. But in C++, if sum is a global variable, it's initialized to 0. So that's okay. But during the loop, for each i, add is called, which adds to sum. So sum is the total of all the sums from each base conversion.

But in the pseudocode, the sum is created once, so in C++, it's a global variable. So I'll declare int sum; globally. Then in main, after processing all i's, compute the gcd.

Putting it all together:

First, the global variable sum.

Then the gcd function.

Then the add function.

Then the main function.

But wait, in C++, the order matters. Functions need to be declared before they are used. So the gcd function is used in main, so either we need to put it before main, or use a forward declaration.

Same for add function. So the order would be:

int sum;

int gcd(int a, int b) {
    if (a % b == 0) return b;
    return gcd(b, a % b);
}

void add(int n, int x) {
    while (n != 0) {
        sum += n % x;
        n = n / x;
    }
}

int main() {
    int n;
    cin >> n;
    sum = 0; // Wait, in the pseudocode, sum is created once. But in the main function, when processing a new n, do we reset sum? The pseudocode says in main, create integer n, read n, then for loop. The sum is declared once, so in the pseudocode, perhaps it's initialized to 0 each time. But in the given pseudocode, the 'create integer sum' is outside. So in the code, sum is a global variable, initialized to 0. But during each run of main, before the loop, sum is 0. But in the code as written, if sum is global, then between different runs (if any) it would retain value, but the main function is called once. So in the code, during the main function, sum starts as 0, then the loop adds to it. So in the code, the global sum is correct.

Wait, but in the pseudocode, the 'create integer sum' is outside. So yes, in C++, it's a global variable. So in the main function, when processing, sum is initially 0. Then during the loop, for each i from 2 to n-1 (exclusive), add(n, i) is called. Each add adds the sum of digits of n in base i. Then after all that, compute the gcd between sum and (n-2). Then print as reduced fraction.

So in code:

In main:

int n;
cin >> n;

sum = 0; // Wait, no. Because sum is a global variable, it's initialized to 0. But during the loop, it's being added to. So before the loop, sum is 0, and after all the add calls, it's the total. So no need to set to 0 again. Wait, but if the code is run multiple times (like in multiple test cases), but the pseudocode's main function is for a single run. So in the code, sum is initialized to 0 once. Then, when main is executed, the sum starts as 0, and the loop adds to it. So no problem.

But wait, if the code is run once, then sum is 0 initially. Then during the loop, it's incremented. So the code is okay.

So the code for main is:

int main() {
    int n;
    cin >> n;
    for (int i = 2; i < n; ++i) {
        add(n, i);
    }
    int div = gcd(sum, n - 2);
    cout << sum / div << '/' << (n - 2) / div << endl;
    return 0;
}

But wait, the gcd function as written may have issues. For example, if a is not divisible by b, it returns gcd(b, a%b). But what if b is zero? However, in the main function, when we call gcd(sum, n-2), sum is the sum of digits across all bases. Let's think: when n is 2, the loop runs from i=2 to n exclusive (i < n is 2 < 2, which is false). So the loop doesn't run. sum remains 0. Then n-2 is 0. So we call gcd(0, 0). Which would cause a division by zero in the first step. But the problem says that the pseudocode is correct and complete, so perhaps n is at least 3. But in code, we need to handle that. However, according to the problem statement, the pseudocode is correct, so perhaps the input n is such that this doesn't happen. So we proceed.

Another thing: the gcd function. The standard Euclidean algorithm is usually written as: while b is not zero, replace (a, b) with (b, a mod b). But here, the function is recursive. Let's see: suppose a and b are positive integers. For example, if a is 8 and b is 4, returns 4. If a is 10 and b is 3, then 10%3 is 1, so call gcd(3,1). Then 3%1 is 0, return 1. Correct. But what if a is smaller than b? For example, a=3, b=6. Then 3%6 is 3, so returns 6? No, wait, the function is called with a and b. Wait, the function is declared with (int a, int b). Suppose a is 3 and b is 6. Then a % b is 3. So the function returns gcd(6, 3). Then in that call, 6%3 is 0, returns 3. Which is correct. So the function works even if a < b. Because in the first call, if a is 3, b is 6, then the next call is gcd(6, 3), which then returns 3. So the function is okay.

But what if b is zero? For example, if someone calls gcd(a, 0). Then in the first line, a%0 would be undefined. But in the main function, when we call gcd(sum, n-2), if sum is 0 and n-2 is 0, that's a problem. But again, the problem says the pseudocode is correct, so perhaps the input ensures that this doesn't happen.

Now, putting all together.

The code:

#include lines are already provided, so we don't include them.

So the code would be:

int sum;

int gcd(int a, int b) {
    if (a % b == 0) return b;
    return gcd(b, a % b);
}

void add(int n, int x) {
    while (n != 0) {
        sum += n % x;
        n = n / x;
    }
}

int main() {
    int n;
    cin >> n;
    for (int i = 2; i < n; ++i) {
        add(n, i);
    }
    int div = gcd(sum, n - 2);
    cout << sum / div << '/' << (n - 2) / div << endl;
    return 0;
}

Wait, but in the pseudocode, the for loop is "for i = 2 to n exclusive". So in C++, the loop is for (int i=2; i < n; ++i). Correct.

Testing with sample input. Let's take n=4. Then i runs 2 and 3.

For i=2, add(4, 2):

n is 4, x is 2.

Loop: n is not 0. sum += 4%2=0. sum is 0. Then n becomes 4/2=2. Next iteration: n=2, sum += 2%2=0. sum remains 0. n becomes 1. Next iteration: 1%2=1, sum +=1 → sum is 1. n becomes 0. So sum is 1.

Then i=3: add(4,3). 4 in base 3 is 11. Sum is 1+1=2. So during add:

n=4, x=3.

n !=0. sum +=4%3=1 → sum becomes 1+1=2. n becomes 4/3=1. Next iteration: 1%3=1, sum becomes 2+1=3. n becomes 0. So sum is 3.

So total sum is 3. n-2 is 4-2=2. gcd(3,2) is 1. So output is 3/2.

Which seems correct. The sum of all digits in bases 2 and 3 is 1 + 2 (wait, for i=2, the sum was 1? Let me recheck. For 4 in base 2: digits are 100 → sum is 1. For base 3: 11 → sum 1+1=2. So total sum is 1+2=3. n-2 is 2. So 3/2. Correct.

So the code seems to handle that.

Another test case: n=3. Then the loop runs for i=2. add(3,2). 3 in base 2 is 11 → sum is 1+1=2. sum is 2. n-2 is 1. gcd(2,1) is 1. Output is 2/1 → 2/1. Which is correct.

So the code seems to work.

Now, check for n=2. Then the loop runs for i < 2 → no iterations. sum is 0. n-2 is 0. So trying to compute gcd(0,0). Which would cause a division by zero in the gcd function. But according to the problem statement, the pseudocode is correct and complete. So perhaps the input n is at least 3. The code may crash for n=2, but the problem says the pseudocode is correct, so perhaps the input is such that n is ≥3. Since the problem says the pseudocode is correct, we proceed.

So the code is as written.
</think>

```cpp
int sum;

int gcd(int a, int b) {
    if (a % b == 0) return b;
    return gcd(b, a % b);
}

void add(int n, int x) {
    while (n != 0) {
        sum += n % x;
        n = n / x;
    }
}

int main() {
    int n;
    cin >> n;
    for (int i = 2; i < n; ++i) {
        add(n, i);
    }
    int div = gcd(sum, n - 2);
    cout << sum / div << '/' << (n - 2) / div << endl;
    return 0;
}
```