<think>
Okay, let's see. I need to convert this pseudocode into C++. Let me go through each part step by step.

First, the pseudocode starts by creating an integer vector array vec with size 3. So in C++, that would be a vector of vectors. Like vector<vector<int>> vec(4). Then there's a map-like structure from string to integer. Oh right, the pseudocode uses "like" which probably refers to a std::map or unordered_map. Since the keys are strings and the values are integers, I'll use a map<string, int> called like.

Next, they declare several integers: diff, ans, a, b, c, and a 2D array mat of size 10x10. So mat can be a 2D array, maybe int mat[10][10], since the size is fixed.

Then there's a function called cal. Inside cal, they declare sum, i, j, k with sum initialized to 0. Then loops: i from 0 to 3 exclusive (so 0-2), j from 0 to the size of vec[i], but wait, the pseudocode says "for j = 0 to integer casted size of vec[i]". Wait, in C++, for loops are usually for (int j = 0; j < vec[i].size(); j++). But the inner loop for k is from 0 to integer casted size of vec[i] exclusive. So for k, it's looping through the size of vec[i], so same as j's loop. But j's loop, maybe the original pseudocode meant j runs up to the size? Like, maybe j is from 0 to vec[i].size() - 1? Or maybe there's a typo. Let me check again.

Original pseudocode for cal function:

for i = 0 to 3 exclusive (so i runs 0,1,2)
    for j = 0 to integer casted size of vec[i] (maybe j runs from 0 to size, inclusive? But that's not possible. Wait, in C++ terms, maybe it's for (j=0; j <= vec[i].size(); ...), but that would be up to size, which is one past the end. But vec[i].size() is the number of elements, so indexes are 0 to size-1. So maybe the pseudocode's "exclusive" part is for the upper limit. For example, "for i = 0 to 3 exclusive" translates to i < 3. So for j, the pseudocode says "for j = 0 to integer casted size of vec[i]". If it's exclusive, then j runs up to but not including the size. But the way it's written here, the j loop's upper limit is not clear. Let me look again:

Original line: for j = 0 to integer casted size of vec[i]. Then for k, it's for k = 0 to integer casted size of vec[i] exclusive. So for k, it's up to but not including the size. So for j, maybe it's up to and including? Or maybe there's a mistake here. Because if both loops are for j and k, but the k loop is exclusive, perhaps j's loop is inclusive? But that would be a problem. For example, if vec[i].size() is 5, then j would go up to 5, which would be out of bounds. Wait, maybe the pseudocode is written in a way that for j, the loop is from 0 to size-1 inclusive. But the way it's written is ambiguous. Let me think again.

In the pseudocode for the cal function:

for i from 0 to 3 exclusive (so i < 3)
    for j from 0 to integer casted size of vec[i] (maybe j runs up to vec[i].size()? Like j <= size? Or j < size? Similarly for k, it's exclusive. So for k, it's from 0 to size-1. So perhaps for j, the loop is from 0 to size-1 inclusive. But the pseudocode says "to integer casted size of vec[i]". Maybe the j loop is written as j < vec[i].size()? So in code, for (j=0; j < vec[i].size(); j++).

But the pseudocode for j's loop says "to integer casted size of vec[i]"â€”maybe that's a typo and meant "exclusive". Because otherwise, if j runs up to the size, which is one past the end, that's an error. So perhaps the j loop is intended to run from 0 to vec[i].size() - 1 inclusive, which would be j < vec[i].size(). So for j, the loop is for (int j=0; j < vec[i].size(); j++).

Then for k, it's from 0 to integer casted size of vec[i] exclusive. Which again would be the same as j's loop. Wait, but then why have two loops? Maybe there's a mistake in the pseudocode. But according to the pseudocode, inside the cal function, there are three nested loops: i, j, k. For each i, j runs from 0 to the size of vec[i], and for each j, k runs from 0 to the same size. But perhaps the j loop is for some outer loop and k is inner. The code inside the loop is incrementing sum by mat[vec[i][j]][vec[i][k]]. So for each i, j, and k, they are accessing vec[i][j] and vec[i][k]. But if j and k are both indices into vec[i], then they must be within the valid range. So the loops for j and k must be from 0 to size-1. Therefore, the pseudocode's j loop probably has a typo and should be "exclusive" as well. But given the pseudocode as written, perhaps the j loop runs from 0 to vec[i].size() inclusive? That would be a problem. But since the problem says the pseudocode is correct and complete, perhaps I need to follow it as written. However, given that in the k loop, it's exclusive, and the code is correct, maybe the j loop is intended to run up to the size. But that's impossible. Wait, maybe the pseudocode for j is written as "for j = 0 to integer casted size of vec[i] exclusive"? But the original says "for j = 0 to integer casted size of vec[i]" (without exclusive). Hmm. This is a bit confusing. Let me check again.

Original pseudocode lines for cal function:

for i = 0 to 3 exclusive
    for j = 0 to integer casted size of vec[i]
        for k = 0 to integer casted size of vec[i] exclusive, increment sum by mat[vec[i][j]][vec[i][k]]
end block

Wait, the j loop's upper limit is written as "to integer casted size of vec[i]" without exclusive. But the k loop is "exclusive". So perhaps the j loop is written as j runs from 0 to the size (inclusive?), but that would be incorrect. But maybe the pseudocode is using a different convention. For example, in some pseudocode notations, "for i from a to b" includes both a and b. So if the size is, say, 3, then j would run 0, 1, 2, 3. But that's impossible. So perhaps there's a mistake here. But since the problem says the pseudocode is correct and complete, I have to assume that the code is correct. Maybe the j loop is written as j runs from 0 to vec[i].size() - 1 inclusive, and the pseudocode's wording is just ambiguous. Alternatively, perhaps the j loop is for (int j=0; j < vec[i].size(); j++) and the k loop is the same. Then, in the code, the line would be sum += mat[vec[i][j]][vec[i][k]]. So that's possible.

So I'll proceed under the assumption that for j, the loop is from 0 to vec[i].size() - 1 inclusive. So the code for the j loop is for (int j=0; j < vec[i].size(); j++).

Now, the cal function returns sum. So the cal function is a function that returns an int. So in C++, we can write it as int cal() { ... }.

Then there's the count function, which takes an integer now and returns void. The function has some logic. Let's see:

Inside count, if now is 7, then check if the sizes of vec[0], vec[1], vec[2] are all non-zero? Wait, the pseudocode says "if size of vec[0] and size of vec[1] and size of vec[2]". Probably, this means that all of them are non-zero. But how? Maybe the original pseudocode is checking if all the sizes are non-zero. For example, if (vec[0].size() && vec[1].size() && vec[2].size())? But that would be true if all are non-zero. But in the code, when now is 7, they create an integer array x with x = { a / size of vec[0], ... }, etc. So the sizes must be non-zero to avoid division by zero. Hence, the check is probably to ensure that all vec[i] have non-zero sizes. So the code would be if (vec[0].size() && vec[1].size() && vec[2].size()).

Once that's true, they create x as {a / vec[0].size(), b / vec[1].size(), c / vec[2].size()}. Then sort x, and check if x[2] - x[0] is less than diff. If so, set diff to that value and ans to cal(). Else if equal, set ans to max of ans and cal().

Then, for the recursive part, for each i from 0 to 3 exclusive (so 0-2?), wait, the pseudocode says "for i = 0 to 3 exclusive". Wait, the original code for the count function's loop says "for i = 0 to 3 exclusive". So i runs 0, 1, 2. For each i, add now to the end of vec[i], call count(now + 1), then remove the last element.

Now, in C++, for the vec, which is a vector of vectors, adding to the end is push_back. So for each i in 0-2, push now into vec[i], call count(now+1), then pop_back.

Now, the main function. The main function sets like["Anka"] to 0, like["Chapay"] to 1, etc. So the map is initialized with these key-value pairs. Then, read n, and process while read n is true. So in C++, perhaps a loop that reads n until EOF or some condition. But in practice, maybe using a while (cin >> n) loop.

Then, for each test case, they set diff to (1 << 31) - 1. Which is the maximum possible 32-bit signed integer (since 1 << 31 is -2147483648 in two's complement, but (1 << 31) -1 would be 2147483647 if using unsigned, but in C++, shifting 1 left 31 bits when using int (32-bit) would be undefined behavior for signed integers. Wait, but the problem says that the pseudocode is correct. So perhaps in the pseudocode, they mean the maximum integer value. So in C++, we can set diff to INT_MAX, which is available in <climits>, which is already included.

Then, for i from 0 to 3 exclusive, remove all elements from vec[i]. So for each of the first 3 vectors (vec[0], vec[1], vec[2]?), clear them. Because the original vec has size 3? Wait, the first line says create integer vector array vec with size 3. So vec is a vector of 3 vectors. So in C++, vec is vector<vector<int>> vec(3);. So for i from 0 to 3 exclusive (i=0,1,2), clear vec[i]. So vec[i].clear().

Then, set bytes from mat to size of mat to value 0. Which probably means to reset all elements of mat to 0. Since mat is a 10x10 array, we can do memset(mat, 0, sizeof(mat)), but since mat is a 2D array, perhaps in C++ it's declared as int mat[10][10]; and then memset(mat, 0, sizeof(mat)).

Then, for i from 0 to n exclusive, read name1, str, name2. Then increment mat[like[name1]][like[name2]]++. So for each line, we read three strings, and increment the corresponding mat entry.

After that, read a, b, c. Then run count with 0 as argument. Then print diff, ans, etc.

Now, putting all together.

First, the global variables:

vector<vector<int>> vec(3); // since the pseudocode says size 3.

map<string, int> like;

int mat[10][10];

int diff, ans, a, b, c;

Wait, but in C++, global variables are allowed. So we can have:

vector<vector<int>> vec(3);

map<string, int> like;

int mat[10][10];

int diff, ans, a, b, c;

Then, the cal function:

int cal() {
    int sum = 0;
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < vec[i].size(); ++j) {
            for (int k = 0; k < vec[i].size(); ++k) {
                sum += mat[vec[i][j]][vec[i][k]];
            }
        }
    }
    return sum;
}

Wait, but the pseudocode's loops for j and k are both for the same condition. But the pseudocode says for j's loop, it's "to integer casted size of vec[i]" and for k's loop, it's "exclusive". But in the code above, j runs up to vec[i].size() - 1 (since j < vec[i].size()), and k runs the same. So perhaps the pseudocode's wording for j's loop is a mistake, but the code is correct.

Then, the count function. Since it's recursive and uses the global variables, it's a void function taking an int.

void count(int now) {
    if (now == 7) {
        if