<think>
Okay, let's see. I need to convert this pseudocode into C++. Let me go through each line carefully.

First, the constants. The pseudocode says create constant integer inf as 1e9 cast to integer. So in C++, that would be int inf = 1e9;. But wait, 1e9 is a floating point, so static_cast<int> might be better. But in practice, 1e9 is 1000000001, which is within int range. So maybe just int inf = 1e9;. Similarly, mod is inf +7, so mod is 1e9+7. Then eps is 1e-9 as a double, and pi is acos(-1.0). Oh right, the pseudocode says acosign of -1.0, probably acos(-1.0) in C++.

Then, integers r, g, b. So variables declared in the global scope? Or inside main? Well, in the pseudocode, in the main function, they read r, g, b. So probably they are local variables in main.

The main function: in C++, it's int main().

The pseudocode says read r, read g, read b. So probably using cin >> r >> g >> b;.

Then ans is initialized to 30. Then a loop from i=1 to 100000 exclusive, so i runs from 1 to 99999. So for (int i = 1; i < 100000; ++i).

Inside the loop, check i mod 3. For each case, increment ans by 1, and decrement the corresponding color by 2. For example, if i%3 is 1, increment ans, decrement r by 2. Wait, the pseudocode says increment ans. So ans starts at 30, then each iteration adds 1, but depending on which condition is met. Wait, each iteration only one of the three conditions is true. Because i mod 3 can be 0,1,2. So each iteration, exactly one of the three if blocks is executed. So each time, ans is increased by 1. Then, after adjusting the color, check if all three are <=0. If so, print ans -1, then return 0 from the function.

Wait, the pseudocode says: return print ans -1 print newline, 0 from function. So when the condition is met, output ans-1 followed by a newline, and return 0. So in C++, that would be cout << ans-1 << endl; then return 0;.

But in the loop, after each step, we check if r, g, b are all <=0. So once any of these steps makes all three <=0, we output ans-1 and exit.

Wait, but why ans-1? Let me think. Let's see the initial ans is 30. Then, for each iteration of the loop, ans is incremented by 1. But perhaps the loop adds steps, but the correct answer is the number of steps taken. Let's think: suppose that after 0 steps, the initial r, g, b are all <=0. Then ans is 30, but we need to output ans-1 = 29? That seems odd. But according to the pseudocode's logic, maybe the initial ans is set to 30, and during each iteration, ans is increased by 1. So perhaps there's a miscalculation here, but the pseudocode says to output ans-1 when the condition is met. So we have to follow that.

Now, the loop runs up to 100,000 times. But given that in each step, we subtract 2 from one of the colors, and check if all are <=0. So for example, if in the first iteration (i=1, which mod 3 is 1), we decrement r by 2. Then check if r, g, b are all <=0. If yes, output ans-1 (30+1=31? Wait, initial ans is 30. Then increment ans by 1 before that. So in the first iteration, ans becomes 31. Then if after that, the colors are all <=0, output 31-1=30. So why?

Hmm, perhaps the ans is counting the number of steps taken. Let me think. Suppose that each step represents an action. Let's say that the initial ans is 30. Then, for each step (i from 1 to ...), we do one action. So if after the first action (i=1), the total steps is 1. But ans starts at 30 and is incremented by 1 each time. So ans is 30 + number of steps. But when we output ans-1, that would be 30 + steps -1 = 29 + steps. That seems odd. But perhaps there's a mistake in the pseudocode's logic. However, since the pseudocode is given as correct and complete, I have to follow it as written.

So the code is to be written exactly as per the pseudocode.

Now, in C++, the code structure would be:

Constants:

const int inf = 1e9;
const int mod = inf +7;
const double eps = 1e-9;
const double pi = acos(-1.0);

But in the pseudocode, the constants are declared in the global scope. However, in C++, the main function is where the variables r, g, b are read. So in the main function:

int main() {
    int r, g, b;
    cin >> r >> g >> b;
    int ans = 30;
    for (int i=1; i < 100000; ++i) {
        if (i % 3 == 1) {
            ans++;
            r -= 2;
        }
        if (i %3 == 2) {
            ans++;
            g -=2;
        }
        if (i%3 ==0) {
            ans++;
            b -=2;
        }
        if (r <=0 && g <=0 && b <=0) {
            cout << ans-1 << endl;
            return 0;
        }
    }
}

Wait, but in the pseudocode, for each i, exactly one of the three conditions is true, so each iteration, ans is incremented once. However, in the code above, each of the three if statements checks for i%3. For example, when i%3 is 1, the first if is true, ans increments, and the other two are skipped. So the code would increment ans once per loop. But the code as written would have three if statements. For example, when i is 3, i%3 is 0. So the third if is triggered, ans increments by 1, and then check the condition.

But in the pseudocode, each of the three conditions is part of a separate if block. So they are separate if statements, not else if. But since i mod 3 can only be one of the three values, only one of the three if's will be true. So in code, it's okay to have three separate if statements. However, in practice, even if two of the conditions were somehow true (which they can't be), the code would increment ans twice. But since that's impossible here, the code is okay.

Now, after incrementing ans and modifying the respective color, check if all are <=0. If so, print ans-1 and exit.

But why ans-1? Let's think of an example. Suppose that in the first iteration (i=1), the code increments ans from 30 to 31, subtracts 2 from r. Suppose that after that, r, g, b are all <=0. Then ans-1 is 30, which is output. But why?

Maybe the initial ans is 30, and each step adds 1. But perhaps the correct answer is the number of steps taken. Let's think: suppose that each step is a move, and the answer is the number of moves. Let's say that in the first step, there's 1 move. Then ans starts at 30, and after incrementing once, it's 31. So ans-1 would be 30. Which is 30 + 1 -1 = 30. So perhaps the initial value of ans is 30, but the actual answer is steps taken. But why is ans initialized to 30?

This seems odd, but since the pseudocode is given as correct, perhaps there's some logic in the problem that we are not seeing. For example, maybe the problem is to find the minimal number of steps plus 30, but then subtract 1. But regardless, the code must follow the pseudocode.

Another thing: the loop runs up to 1e5-1. But what if the condition is never met? Then after the loop, the code would exit. But according to the problem statement, the pseudocode is correct and complete, so perhaps the loop is guaranteed to break early.

Now, coding this in C++. Also, note that the variables r, g, b are modified in each iteration. For example, each time, subtract 2 from one of them.

Potential issues: if the initial values of r, g, b are such that they are all <=0. Then, before any loop iterations, the code would not have entered the loop. So in that case, the code would not check the condition. So the code would not output anything. But according to the pseudocode's logic, in that case, the answer would be ans-1 = 30-1=29? Which seems wrong. But according to the pseudocode's code, the loop starts at i=1. So the initial check for r, g, b <=0 is not done. So perhaps the pseudocode assumes that the initial values are positive. Or perhaps there's a mistake in the pseudocode. But again, since the pseudocode is correct and complete, perhaps the problem ensures that the initial values are positive. So the code as written would handle all cases.

So in the code, after modifying the variables in each iteration, check if all are <=0. So the code is correct.

So putting it all together, the C++ code would be:

The constants are declared, but in C++, they are declared outside main? Or inside main? Well, in the pseudocode, they are constants. So in C++, they can be declared as global constants. However, the user's instruction says that the given libraries are already included. So the code should not include them again.

So the code would have:

const int inf = 1e9;
const int mod = inf +7;
const double eps = 1e-9;
const double pi = acos(-1.0);

But the user's instruction says that the code given in the task already includes those libraries. However, the constants need to be declared. Wait, the pseudocode says to create those constants. So in the C++ code, they need to be declared. But the problem says that the code in the task already includes the given libraries, but the constants are part of the code to be written.

So the code to be written must include those constants. So in the code block, the constants are declared before main.

But in C++, the code would be:

#include ... (but the user says not to include them again). So the code provided by the user will have those includes. So our code must not include them again. Therefore, in our code, we just write the constants, variables, and main function.

So the code would be:

const int inf = 1e9;
const int mod = inf + 7;
const double eps = 1e-9;
const double pi = acos(-1.0);

int main() {
    int r, g, b;
    cin >> r >> g >> b;
    int ans = 30;
    for (int i = 1; i < 100000; ++i) {
        if (i % 3 == 1) {
            ++ans;
            r -= 2;
        }
        if (i % 3 == 2) {
            ++ans;
            g -= 2;
        }
        if (i % 3 == 0) {
            ++ans;
            b -= 2;
        }
        if (r <= 0 && g <= 0 && b <= 0) {
            cout << ans -1 << endl;
            return 0;
        }
    }
    return 0;
}

Wait, but in the pseudocode, after the for loop, there's no code. So in C++, after the loop, perhaps there's nothing. But the main function must return something. So adding return 0; at the end.

But according to the problem, the pseudocode is correct and complete, so the loop must break before 100000 iterations. However, to avoid undefined behavior, the code should return something. So adding return 0; at the end of main.

But perhaps the problem expects that the loop will always find a solution. So in practice, the code will return 0 inside the loop.

Now, check the code against the pseudocode:

The pseudocode says, in the main function, read r, g, b. Then create ans = 30. Then for i from 1 to 100000 exclusive. Then for each i, check the three conditions. For each, increment ans and subtract 2. Then check if all are <=0, if yes, print ans-1 and return 0.

Yes, the code does that.

But in C++, the for loop is written as for (int i=1; i < 100000; ++i) which is correct (i goes up to 99999).

Now, the initial ans is 30. Each iteration, ans is increased by 1. But in the code, for each i, exactly one of the three if conditions is true, so ans is increased once per iteration. Then, after that, check the condition.

But when the condition is met, the code outputs ans-1. For example, suppose after the first iteration, the condition is met. ans was 30, then incremented to 31. Then output 31-1=30. So why?

This suggests that the actual answer is the number of steps taken minus something. But again, the code must follow the pseudocode.

Another thing: the pseudocode says "return print ans -1 print newline, 0 from function". So in C++, that's printing ans-1 and returning 0.

Yes, the code does that.

Now, testing with sample input. Let's say input is r=2, g=2, b=2. Let's see:

Initially, ans=30.

i=1: i%3 is 1.