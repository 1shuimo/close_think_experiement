<think>
Okay, let's see. I need to convert this pseudocode into C++. Let me go through each line carefully.

First, the constants. The pseudocode says create constant integer inf as 1e9 cast to integer. So in C++, that would be int inf = 1e9;. But wait, 1e9 is a floating point, so static_cast<int> might be better. But in practice, 1e9 is 1000000001, which is within int range. So maybe just int inf = 1e9;. Similarly, mod is inf +7, so mod is 1e9+7. Then eps is 1e-9 as a double, and pi is acos(-1.0). Oh right, the pseudocode says acosign of -1.0, probably acos(-1.0) in C++.

Then, integers r, g, b. So variables declared in the global scope? Or inside main? Well, in the pseudocode, in the main function, they read r, g, b. So probably they are local variables in main.

The main function: in C++, it's int main().

The pseudocode says read r, read g, read b. So probably using cin >> r >> g >> b;.

Then ans is initialized to 30. Then a loop from i=1 to 100000 exclusive, so i runs from 1 to 99999. So for (int i = 1; i < 100000; ++i).

Inside the loop, check i mod 3. For each case, increment ans by 1, and decrement the corresponding color by 2. For example, if i%3 is 1, increment ans, decrement r by 2. Wait, the pseudocode says increment ans. So ans starts at 30, then each iteration adds 1, but depending on which condition is met. Wait, each iteration only one of the three conditions is true. Because i mod 3 can be 0,1,2. So each iteration, exactly one of the three if blocks is executed. So each time, ans is increased by 1. Then, after adjusting the color, check if all three are <=0. If so, print ans -1, then return 0 from the function.

Wait, the pseudocode says: return print ans -1 print newline, 0 from function. So when the condition is met, output ans-1 followed by a newline, and return 0. So in C++, that would be cout << ans-1 << endl; then return 0;.

But in the loop, after each step, we check if r, g, b are all <=0. So once any of these steps makes all three <=0, we output ans-1 and exit.

Wait, but why ans-1? Let me think. Let's see the initial ans is 30. Then, for each iteration of the loop, ans is incremented by 1. But perhaps the loop adds steps, but the correct answer is the number of steps taken. Let's think: suppose that after 0 steps, the initial r, g, b are all <=0. Then ans is 30, but we need to output ans-1 = 29? That seems odd. But according to the pseudocode's logic, maybe the initial ans is set to 30, and during each iteration, ans is increased by 1. So perhaps there's a miscalculation here, but the pseudocode says to output ans-1 when the condition is met. So we have to follow that.

Now, the loop runs up to 100,000 times. But given that in each step, we subtract 2 from one of the colors, and check if all are <=0. So for example, if in the first iteration (i=1, which mod 3 is 1), we decrement r by 2. Then check if r, g, b are all <=0. If yes, output ans-1 (30+1=31? Wait, initial ans is 30. Then increment ans by 1 before that. So in the first iteration, ans becomes 31. Then if after that, the colors are all <=0, output 31-1=30. So why?

Hmm, perhaps the ans is counting the number of steps taken. Let me think. Suppose that each step represents an action. Let's say that the initial ans is 30. Then, for each step (i from 1 to ...), we do one action. So if after the first action (i=1), the total steps is 1. But ans starts at 30 and is incremented by 1 each time. So ans is 30 + number of steps. But when we output ans-1, that would be 30 + steps -1 = 29 + steps. That seems odd. But perhaps there's a mistake in the pseudocode's logic. However, since the pseudocode is given as correct and complete, I have to follow it as written.

So the code is to be written exactly as per the pseudocode.

Now, in C++, the code structure would be:

Constants:

const int inf = 1e9;
const int mod = inf +7;
const double eps = 1e-9;
const double pi = acos(-1.0);

But in the pseudocode, the constants are declared in the global scope. However, in C++, the main function is where the variables r, g, b are read. So in the main function:

int main() {
    int r, g, b;
    cin >> r >> g >> b;
    int ans = 30;
    for (int i=1; i < 100000; ++i) {
        if (i % 3 == 1) {
            ans++;
            r -= 2;
        }
        if (i %3 == 2) {
            ans++;
            g -=2;
        }
        if (i%3 ==0) {
            ans++;
            b -=2;
        }
        if (r <=0 && g <=0 && b <=0) {
            cout << ans-1 << endl;
            return 0;
        }
    }
}

Wait, but in the pseudocode, for each i, exactly one of the three conditions is true, so each iteration, ans is incremented once. However, in the code above, each of the three if statements checks for i%3. For example, when i%3 is 1, the first if is true, ans increments, and the other two are skipped. So the code would increment ans once per loop. But the code as written would have three if statements. For example, when i is 3, i%3 is 0. So the third if is triggered, ans increments by 1, and then check the condition.

But in the pseudocode, each of the three conditions is part of a separate if block. So they are separate if statements, not else if. But since i mod 3 can only be one of the three values, only one of the three if's will be true. So in code, it's okay to have three separate if statements. However, in practice, even if two of the conditions were somehow true (which they can't be), the code would increment ans twice. But since that's impossible here, the code is okay.

Now, after incrementing ans and modifying the respective color, check if all are <=0. If so, print ans-1 and exit.

But why ans-1? Let's think of an example. Suppose that in the first iteration (i=1), the code increments ans from 30 to 31, subtracts 2 from r. Suppose that after that, r, g, b are all <=0. Then ans-1 is 30, which is output. But why?

Maybe the initial ans is 30, and each step adds 1. But perhaps the correct answer is the number of steps taken. Let's think: suppose that each step is a move, and the answer is the number of moves. Let's say that in the first step, there's 1 move. Then ans starts at 30, and after incrementing once, it's 31. So ans-1 would be 30. Which is 30 + 1 -1 = 30. So perhaps the initial value of ans is 30, but the actual answer is steps taken. But why is ans initialized to 30?

This seems odd, but since the pseudocode is given as correct, perhaps there's some logic in the problem that we are not seeing. For example, maybe the problem is to find the minimal number of steps plus 30, but then subtract 1. But regardless, the code must follow the pseudocode.

Another thing: the loop runs up to 1e5-1. But what if the condition is never met? Then after the loop, the code would exit. But according to the problem statement, the pseudocode is correct and complete, so perhaps the loop is guaranteed to break early.

Now, coding this in C++. Also, note that the variables r, g, b are modified in each iteration. For example, each time, subtract 2 from one of them.

Potential issues: if the initial<think>
I am not fully confident. Re-check and decide again.
</think>

```cpp
const int inf = 1e9;
const int mod = inf + 7;
const double eps = 1e-9;
const double pi = acos(-1.0);

int main() {
    int r, g, b;
    cin >> r >> g >> b;
    int ans = 30;
    for (int i = 1; i < 100000; ++i) {
        if (i % 3 == 1) {
            ++ans;
            r -= 2;
        }
        if (i % 3 == 2) {
            ++ans;
            g -= 2;
        }
        if (i % 3 == 0) {
            ++ans;
            b -= 2;
        }
        if (r <= 0 && g <= 0 && b <= 0) {
            cout << ans - 1 << endl;
            return 0;
        }
    }
    return 0;
}
```