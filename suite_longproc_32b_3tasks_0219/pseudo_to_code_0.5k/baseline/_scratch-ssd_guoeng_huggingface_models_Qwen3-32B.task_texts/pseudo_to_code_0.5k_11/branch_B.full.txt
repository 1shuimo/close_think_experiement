<think>
Okay, let's see. I need to convert this pseudocode into C++ code. Let me go through each part step by step.

First, the pseudocode mentions creating an integer sum. So in C++, I should declare a global variable sum, maybe? Because later, the add function uses this sum. Oh right, because in the pseudocode, add is a function that modifies the sum. So sum needs to be accessible in both the add function and the main function. So I'll declare sum as a global variable. But wait, in C++, variables declared inside main are local. So if sum is declared inside main, then the add function can't modify it unless it's passed by reference. Wait, looking at the pseudocode's add function: it says "increment sum by n % x". So the sum is a variable that's being modified inside the add function. How is that possible? Well, in the pseudocode, sum is declared in the main, perhaps, and passed to add? Or maybe it's a global variable. The initial line says "create integer sum"â€”probably global.

But in C++, if I declare sum outside of any function, it's global. So I'll need to do that. But the user's instruction says that the code provided already includes certain headers and the using namespace std. So I don't need to include them again. My code will start with that.

So first, I'll declare the sum as a global integer. Then, the gcd function. The gcd function takes two integers a and b. The logic is: if a % b is 1, return b. Otherwise, return gcd(b, a % b). Wait, but in the pseudocode, it says "return result of run gcd with arguments b, a % b from function". So it's a recursive function. So the function is returning the result of calling gcd again. So the base case is when a % b is 0, return b. Otherwise, recurse.

Wait, but the parameters for the gcd function: usually, the Euclidean algorithm is called with (a, b) where a > b. But here, the function is called with a and b, and if a % b is not zero, then we call gcd(b, a%b). So this assumes that a is larger than b? Or does it not matter? Well, the function will still work even if a is smaller than b. For example, if a is 6 and b is 4. Then a % b is 2. Then call gcd(4, 2). Which returns 2. So it works. But if a is smaller than b, then in the first call, a % b is a, and then the next call is gcd(b, a). So for example, if a=4, b=6. Then the first call would be gcd(4,6). Then since 4%6 is 4, then call gcd(6,4). Then 6%4=2, call gcd(4,2), then returns 2. So the function works regardless of the order. But in the pseudocode's gcd function, when you pass a and b, perhaps the initial call is with (sum, n-2) as arguments, which could be in any order. But the function seems to be correctly implemented.

Then the add function. The add function takes integers n and x. The loop runs while n is not 0. Then sum is incremented by n % x, and n is set to n / x. So this is converting n into base x and summing the digits? For example, if n is 5 and x is 2, then the digits are 101, sum is 1+0+1=2. But the add function is adding each digit to the sum. So sum is being accumulated across all calls to add.

In C++, since sum is a global variable, the add function can modify it directly. So the add function would be a void function that takes n and x. Inside, while n != 0, add the remainder to sum and divide n by x.

Now, the main function. Read n. Then for i from 2 to n exclusive, which means i runs from 2 to n-1. For each i, call add(n, i). Then compute the gcd of sum and (n-2), then print sum/div and (n-2)/div as a fraction.

Wait, the main function's steps:

- create integer n, read it.

- for i=2 to n exclusive: run add(n, i). So for each base i from 2 up to n-1, we convert n into base i and sum the digits into sum.

Once all those are done, compute the gcd of sum and (n-2). Then output the sum divided by that gcd, followed by a slash, and (n-2) divided by the gcd.

But why (n-2)? Because for each base from 2 to n-1, there are (n-2) bases. For example, if n is 5, bases are 2,3, so n-2 is 3-2=2? Wait, n is 5, bases from 2 to 4 (since it's exclusive). So 2 and 3. So there are 3-2+1 = 2? Wait, 4-2=2, since for i from 2 to n-1 (exclusive of n), so for n=5, i runs up to 4. So the number of bases is (4-2+1)? Wait, 2,3,4? No, if n is 5, then for i=2 to 5 exclusive is 2,3,4. So three bases. But n-2 is 3. So perhaps the code is using (n-2) as the count? But no, the count is (n-1) - 2 + 1? Let me see: the upper bound is n exclusive. So the loop is for i in 2..n-1 inclusive. The number of elements is (n-1 - 2 + 1) = n-2. So yes, (n-2) elements. But why is that relevant for the gcd?

But according to the pseudocode, after accumulating the sum, we compute the gcd of sum and (n-2). So perhaps the problem is to compute the sum of all digits in all bases, then represent that sum over (n-2) in reduced form. For example, sum/(n-2) as a fraction, simplified by their gcd.

So the code is supposed to calculate the sum of digits of n in all bases from 2 to n-1, then output the sum divided by (n-2) in reduced form.

So the code's logic is correct.

Now, translating into C++.

First, the global variable sum. So:

int sum;

Then the gcd function. But wait, in C++, there's a standard gcd function in <numeric> header since C++17. But according to the included headers, <numeric> is included. However, the problem says that the user will provide pseudocode and we need to generate code. The pseudocode's gcd is a function that takes a and b. But according to the code, the user's code already includes the necessary headers. However, the problem says that the pseudocode is correct and complete, so we can assume that the gcd function is correctly implemented as per the pseudocode.

But in C++, the std::gcd function returns the greatest common divisor of two numbers. However, the way the pseudocode describes the function, perhaps we need to implement it. But according to the pseudocode's logic, the function is recursive. Let me check:

The pseudocode says:

declare gcd with integers a, b as arguments, returning integer
    if a % b is 0, return b
    return result of run gcd with arguments b, a % b from function
end of the block

Wait, but this assumes that a is larger than b. Because if a is smaller than b, then a % b is a, and then the next call is gcd(b, a). Which would then check if b % a is zero, etc. But the parameters here are a and b. Wait, the function is called with a and b. But according to the code, the first call is with sum and (n-2). So sum could be larger or smaller than (n-2). But the function as written will compute the GCD correctly regardless of the order. For example, if a is 4 and b is 6, then a%b is 4, so call gcd(6,4). Then in that function, 6%4=2, call gcd(4,2). Then 4%2=0, return 2. Which is correct.

But according to the function's code, the parameters are a and b. However, the function is written as a recursive function. So in C++, we can implement this as:

int gcd(int a, int b) {
    if (a % b == 0) return b;
    return gcd(b, a % b);
}

But wait, what if b is zero? Well, in the main function, when we call gcd(sum, n-2), the second argument is n-2. Since in the main function, n must be at least 2 (since for i from 2 to n exclusive, if n is 2, then the loop runs from 2<think>
I am not fully confident. Re-check and decide again.
</think>

```cpp
int sum;

int gcd(int a, int b) {
    if (a % b == 0) return b;
    return gcd(b, a % b);
}

void add(int n, int x) {
    while (n != 0) {
        sum += n % x;
        n = n / x;
    }
}

int main() {
    int n;
    cin >> n;
    sum = 0;
    for (int i = 2; i < n; ++i) {
        add(n, i);
    }
    int div = gcd(sum, n - 2);
    cout << sum / div << '/' << (n - 2) / div << endl;
    return 0;
}
```