<think>
Okay, let's see. I need to convert this pseudocode into C++. Let me start by understanding each part.

First, the pseudocode creates a vector of integers with size 3. Wait, in C++, that would be a vector of vectors? Because the pseudocode mentions vec[i], and each might have elements added. Oh right, the pseudocode says "create integer vector array vec with size 4"—so probably a vector of vectors, like vector<vector<int>> vec(3).

Then there's a map from string to integer. The pseudocode uses "like" as the map name. So in C++, that's a map<string, int> like.

The variables diff, ans, a, b, c are integers. Then mat is a 2D array of size 10 by 10. Since in C++, that's probably a 2D array like int mat[10][10].

The cal function is declared. Inside, it initializes sum, i, j, k. Then loops over i from 0 to 3 exclusive (so 0-2), then j from 0 to the size of vec[i], but the pseudocode says "for j = 0 to integer casted size of vec[i]". Wait, in C++, for loops usually go up to size, but need to check if it's exclusive. The first loop for i is up to 3 exclusive, which is standard (i < 3). For j, the pseudocode says "for j = 0 to integer casted size of vec[i]". Hmm, maybe it's j from 0 to (int)vec[i].size(), but in C++ loops, usually you have to check if it's up to size. Like, if it's "exclusive", then j < vec[i].size(). But the pseudocode's wording is a bit ambiguous. Let me check the inner loops.

In the cal function, for j, it's "for j = 0 to integer casted size of vec[i]". The inner loop for k is "for k = 0 to integer casted size of vec[i] exclusive"—so that one is k < vec[i].size(). But for j, the pseudocode says "to integer casted size of vec[i]"—maybe it's inclusive? But in C++, loops usually use < size. Wait, maybe the pseudocode's "exclusive" applies only to the k loop. For j, it's up to the size, but not exclusive. Wait, the wording is "for j = 0 to integer casted size of vec[i]". So maybe j runs from 0 to (int)vec[i].size(), but in C++ terms, that would be j < vec[i].size()? Because if you have a loop from 0 to N, exclusive, it's j < N. So maybe for j, it's the same as k's loop but without the "exclusive" part. Wait, the pseudocode says for k it's "exclusive", but for j it's not. So perhaps for j, the loop is up to and including the size? But that would be a problem because accessing vec[i][j] when j is equal to the size would be out of bounds. Hmm, maybe there's a typo. Let me recheck.

Looking at the pseudocode again:

for i = 0 to 3 exclusive
    for j = 0 to integer casted size of vec[i]
        for k = 0 to integer casted size of vec[i] exclusive, increment sum by mat[vec[i][j]][vec[i][k]]
end of the block

Wait, for j, the loop is "to integer casted size of vec[i]"—so maybe j runs from 0 to (int)vec[i].size() - 1? Or up to the size? Because in C++, if you have a loop like for (j=0; j <= size; ...) that would be j up to size, but that's out of bounds. So perhaps the pseudocode's wording is a bit off, and for j, it's also exclusive. Maybe the "exclusive" was omitted in the pseudocode for j's loop. Otherwise, accessing vec[i][j] when j is equal to the size would be invalid. So I think that for j, the loop is from 0 to (int)vec[i].size() exclusive. So in code, for (j=0; j < (int)vec[i].size(); j++).

Then, inside the k loop, it's from 0 to the same size, exclusive. So the code for the cal function would be:

int cal() {
    int sum = 0, i, j, k;
    for (i = 0; i < 3; i++) {
        for (j = 0; j < (int)vec[i].size(); j++) {
            for (k = 0; k < (int)vec[i].size(); k++) {
                sum += mat[vec[i][j]][vec[i][k]];
            }
        }
    }
    return sum;
}

But wait, the pseudocode says "for j = 0 to integer casted size of vec[i]"—maybe that's j < (int)vec[i].size()? So that's correct.

Now, the count function. It takes an integer now and returns void. If now is 7, then check if the sizes of vec[0], vec[1], vec[2] are non-zero. Then create x as {a / size of vec[0], ...}, sort them, and compare the difference. If the difference is less than current diff, update diff and ans. Else if equal, take max of ans and cal().

But in C++, the vec is a global variable? Because in the pseudocode, the count function is modifying vec by adding and removing elements. So vec, like, mat, diff, ans, a, b, c are all global variables.

So in the code, these variables should be declared in the global scope.

Now, the main function. It sets the like map with various names to 0-6. Then reads n, and processes n lines of name1, str, name2, incrementing mat[like[name1]][like[name2]].

Then reads a, b, c. Then runs count(0). Then prints diff and ans.

Now, implementing the count function. The function is recursive. For each now from 0 to 6 (since when now is 7, it does the check), it adds now to each of the three vec[i], then calls count(now+1), then removes it (backtracking).

Wait, the pseudocode says:

for i = 0 to 3 exclusive
    add element now to end of vec[i]
    run count with now + 1 as argument
    remove last element from vec[i]
end of the block

But there are 3 vecs (vec[0], vec[1], vec[2]). So for each i in 0-2 (since 3 exclusive), add now to vec[i], then recurse, then backtrack.

So in code, the count function would be:

void count(int now) {
    if (now == 7) {
        if (vec[0].size() && vec[1].size() && vec[2].size()) {
            int x[3] = {a / (int)vec[0].size(), b / (int)vec[1].size(), c / (int)vec[2].size()};
            sort(x, x + 3);
            if (x[2] - x[0] < diff) {
                diff = x[2] - x[0];
                ans = cal();
            } else if (x[2] - x[0] == diff) {
                ans = max(ans, cal());
            }
        }
        return;
    }
    for (int i = 0; i < 3; i++) {
        vec[i].push_back(now);
        count(now + 1);
        vec[i].pop_back();
    }
}

But wait, the pseudocode says "add element now to end of vec[i]". So the 'now' is the current value (like 0, then 1, etc.), and adding it to vec[i]. So each vec[i] collects the sequence of numbers from 0 to 6, but partitioned into the three vecs. But when now is 7, the check is done.

Now, the variables diff and ans are initialized. In the main function, before processing each test case, diff is set to (1 << 31) - 1, which is a very large value (since 1<<31 is 2^31, but since it's signed, that would be -2^30, but (1<<31) -1 would be undefined in C++ for signed integers. Wait, the pseudocode says set diff to (1 bitshift left 31) - 1. In C++, shifting 1 left by 31 is undefined for a signed int (since 32-bit int, shifting 1<<31 would be a negative value on two's complement). But perhaps the intention is to set diff to a very large value, like INT_MAX. So in C++, we can set diff = INT_MAX.

But in the code, the pseudocode says:

set diff to (1 bitshift left 31) - 1

Which in C++ would be (1 << 31) - 1. But for a 32-bit signed int, 1 << 31 is undefined. However, if we use unsigned int, then 1 << 31 is allowed. But perhaps the intention is to set diff to the maximum possible value. So maybe using INT_MAX from <climits> is better. The code in the main function would have:

diff = (1 << 31) - 1;

But that's not correct in C++ for signed integers. So perhaps the correct approach is to use INT_MAX. Let me check. The code includes <climits>, so we can use INT_MAX. So in the main function, when initializing diff, set it to INT_MAX.

Now, the mat array is initialized to zero. The pseudocode says "set bytes from mat to size of mat to value 0"—so in C++, that's memset(mat, 0, sizeof(mat))? But mat is a 10x10 array, so yes.

Now, putting all together.

Global variables:

vector<vector<int>> vec(3);
map<string, int> like;
int diff, ans, a, b, c;
int mat[10][10];

Then the cal function returns sum as described.

The count function is void and recursive.

In main, the like map is filled with the given names and their values 0-6.

Then, for each test case, read n, then process n lines of name1, str, name2, incrementing mat[like[name1]][like[name2]].

Then read a, b, c. Then call count(0). Then print diff and ans.

Now, handling the input. The pseudocode says "read n" in a loop. So in C++, while (cin >> n), but need to read the entire line. However, the input may have multiple test cases. But the code uses while (read n is true). So in C++, perhaps:

while (cin >> n) {
    // process
}

But after reading n, the code reads n lines of name1, str, name2. Then reads a, b, c. So in code:

string name1, str, name2;
for (i = 0; i < n; i++) {
    cin >> name1 >> str >> name2;
    mat[like[name1]][like[name2]]++;
}

Then read a, b, c: cin >> a >> b >> c;

Now, the code for the main function.

Putting all together.

Now, possible issues:

- The mat is a 10x10 array. The like map has 7 entries (Anka to Hexadecimal, 0-6). So mat is 10x10, which is okay.

- The vec is a vector of 3 vectors. Each can have elements added. The count function adds numbers 0-6 into the vecs, and when now reaches 7, it checks if each vec has at least one element. Because in the pseudocode, when now is 7, it checks if the sizes of vec[0], vec[1], vec[2] are non-zero. So the condition is if (vec[0].size() && vec[1].size() && vec[2].size()).

Another thing: in the cal function, the code loops i from 0 to 3 exclusive (i < 3), then for each i, j and k loop over the size of vec[i]. But the vec has 3 elements (vec[0], vec[1], vec[2]). So the code for cal is summing over all three vecs.

Now, the code for the cal function.

Now, the code for the count function. The function is recursive, and for each now from 0 to 6, adds to each of the three vecs, then backtracks.

Now, putting all into C++ code.

Now, the code:

#include the given headers, but the user says not to include them again. So the code should not have those includes.

Now, the code:

vector<vector<int>> vec(3);
map<string, int> like;
int diff, ans, a, b, c;
int mat[10][10];

int cal() {
    int sum = 0, i, j, k;
    for (i = 0; i < 3; i++) {
        for (j = 0; j < (int)vec[i].size(); j++) {
            for (k = 0; k < (int)vec[i].size(); k++) {
                sum += mat[vec[i][j]][vec[i][k]];
            }
        }
    }
    return sum;
}

void count(int now) {
    if (now == 7) {
        if (vec[0].size() && vec[1].size() && vec[2].size()) {
            int x[3] = {a / (int)vec[0].size(), b / (int)vec[1].size(), c / (int)vec[2].size()};
            sort(x, x + 3);
            if (x[2] - x[0] < diff) {
                diff = x[2] - x[0];
                ans = cal();
            } else if (x[2] - x[0] == diff) {
                ans = max(ans, cal());
            }
        }
        return;
    }
    for (int i = 0; i < 3; i++) {
        vec[i].push_back(now);
        count(now + 1);
        vec[i].pop_back();
    }
}

int main